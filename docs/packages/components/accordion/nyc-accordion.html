<!-- Generated from 64a6edc on 2023-07-10 @ 19:05 with Emacs 29.0.92 (Org mode 9.6.6) -->
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta author="Michael Mausler - NYC"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="icon" type="image/png" href="/img/favicon.png"/><link rel="stylesheet" href="https://nycdigitalservice.github.io/dof-design-system/assets/dof-2023-styles.css"/><link rel="stylesheet" href="https://nycdigitalservice.github.io/dof-design-system/assets/dof-2023-docs.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/nord.min.css"/><link rel="stylesheet" href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css"/><title>NYCAccordion - NYC</title></head><body class="u-reset"><header class="background-primary"><nav class="p-2 flex"><a href="/" class="mr-auto flex"><img class="logo" height="50" src="https://nycdigitalservice.github.io/dof-design-system/assets/img/nyc-dof-logo.svg" alt="NYC Department of Finance"/></a><button is="toggle-button" id="main-menu-control" class="button" aria-controls="main-menu"><i class="i-ri:menu-line mr-2"></i>Menu</button></nav></header><aside id="main-menu" class="background-primary-lightest" aria-labelledby="main-menu-control" hidden=""><div class="container grid p-4"><nav class="flex flex-col"><span class="p-2 border-b-2 border-current border-solid">Main</span><a class="p-2" href="https://nycdigitalservice.github.io/dof-design-system/">Home</a><a class="p-2" href="https://nycdigitalservice.github.io/dof-design-system/packages/">Packages</a><a class="p-2" href="https://nycdigitalservice.github.io/dof-design-system/packages/components/">Components</a></nav><nav class="flex flex-col"><span class="p-2 border-b-2 border-current border-solid">Components</span><a class="p-2" href="https://nycdigitalservice.github.io/dof-design-system/packages/components/accordion/">Accordion</a><a class="p-2" href="https://nycdigitalservice.github.io/dof-design-system/packages/components/alert/">Alert</a><a class="p-2" href="https://nycdigitalservice.github.io/dof-design-system/packages/components/button/">Button</a><a class="p-2" href="https://nycdigitalservice.github.io/dof-design-system/packages/components/card/">Card</a></nav></div></aside><main class="container"><div class="region flow"><h1 class="site-post-title">NYCAccordion</h1><div id="content" class="flow"><p>
The <code>nyc-accordion</code> custom element will scan its children and attempt to
format them with the required markup. You can supply it with
alternating heading and panel elements and it will apply the required
attributes.
</p>

<nyc-accordion><h3>Inspect code</h3><div><pre><code class="language-js">import {toggle,chunkArray} from '../../../core/js';

const isAlternating = n => n.every((el, i) => {
  return n[i&1].nodeName == el.nodeName;
})

const chunki = (arr, cond) => {
  const res = [];
  let chunk = [];

  // Iterative
  for (const i of arr) {
    if (cond(arr[i]) && chunk.length > 0) {
      res.push(chunk);
      chunk = []
    }
    chunk.push(arr[i])      
  }

  if (chunk.length > 0) {
    res.push(chunk);
  }

  return res;
}

const chunkr = (arr, cond) => {
  const res = [];
  let chunk = [];

  // Recursive
  (function chunky(ns){
    if (Array.isArray(ns) && !ns.length) {
      res.push(chunk);
      return;
    }
    if (cond(ns[0]) && chunk.length > 0) {
      res.push(chunk);
      chunk = []
    }
    chunk.push(ns.shift())
    return chunky(ns);
  })(arr)

  return res;
}

class NYCAccordion extends HTMLElement {
  constructor() {
    super();
    this.headings = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6']
    this.panels = ['DIV','SECTION'];
  }
  connectedCallback() {
    if (!this.firstChild) return;
    this.groups = this.querySelectorAll(':scope > .accordion__group');
    // If we have groups, format them
    if (this.groups.length > 0) {
      this.groups.forEach(this.formatGroup.bind(this));      
    } else {
      // We don't have groups, remove empty nodes and 
      const nodes = this.removeEmptyTextNodes(this.childNodes);
      // console.log(nodes);
      // console.log(isAlternating(nodes))
      if (this.headings.includes(nodes[0].nodeName)) {

        const headingNodeName = nodes[0].nodeName;

        const groupsArr = chunkr(nodes, (n) => n.nodeName === headingNodeName)

        const groups = groupsArr.map(group => {
          const frag = new DocumentFragment();
          group.forEach(el => frag.appendChild(el))

          const groupEl = this.createGroup(frag);
          return groupEl;
        })

        groups.forEach(this.formatGroup.bind(this));
        this.append(...groups);
        // return;
      } else if (isAlternating(nodes)) {
        const groups = chunkArray(nodes, 2);
        // console.log(groups);
        const frags = groups.map(group => {
          const frag = new DocumentFragment();
          group.forEach(el => frag.appendChild(el))

          const groupEl = this.createGroup(frag);
          return groupEl;
        })

        frags.forEach(this.formatGroup.bind(this));
        this.append(...frags);
      } else {
        const group = this.createGroup(this);
        this.appendChild(group);
        this.formatGroup(group);
      }
    }
  }
  createGroup(parent) {
    const groupEl = document.createElement('article');
    groupEl.classList.add('accordion__group');
    const fragment = new DocumentFragment();
    while(parent.hasChildNodes()){
      fragment.appendChild(parent.firstChild)
    }
    groupEl.appendChild(fragment);
    return groupEl;
  }
  formatGroup(group) {
    const nodes = this.removeEmptyTextNodes(group.childNodes);
    const firstChild = nodes[0];
    const siblings = nodes.slice(1);
    const hasHeading = this.headings.includes(firstChild.nodeName);
    // Need a better way to detect panel
    const hasPanel = siblings[0].hasAttribute('hidden') || this.panels.includes(siblings[0].nodeName);
    group.setAttribute('data-panel-id', `panel-${this.generateId()}`);
    // console.log(firstChild, hasHeading, hasPanel);
    if (hasHeading) {
      this.formatHeading(firstChild);
    } else {
      const heading = this.createHeading(group);
      group.prepend(heading);
      this.formatHeading(heading);
    }
    if (hasPanel) {
      this.formatPanel(siblings[0]);
    } else {
      const panel = this.createPanel(siblings);
      group.append(panel);
      this.formatPanel(panel);
    }
  }
  removeEmptyTextNodes(nodelist) {
    const arr = Array.from(nodelist);
    const nonEmpty = arr.filter(node => {
      if (node.nodeName !== '#text') {
        return true;
      } else if (node.data.trim().length > 0){
        return true
      }
    })
    return nonEmpty;
  }
  createHeading(group) {
    const headingEl = document.createElement('h4');
    headingEl.appendChild(group.firstChild);

    return headingEl;
  }
  formatHeading(heading) {
    const firstChild = this.removeEmptyTextNodes(heading.childNodes)[0];

    let headingLabel;
    if (firstChild.nodeName !== 'BUTTON') {
      const button = this.createButton(firstChild, heading.parentNode.dataset.panelId);
      headingLabel = firstChild.data;
      heading.appendChild(button);
    } else {
      headingLabel = firstChild.innerText;
    }
    let headingId = `${headingLabel.trim().replace(/\s+/g, '-').toLowerCase()}-heading`;
    if (document.getElementById(headingId)) {
      headingId = `${headingId}-1`;
    }
    heading.setAttribute('id', headingId);
  }
  createPanel(children) {
    const panel = document.createElement('div')
    panel.append(...children);
    return panel;
  }
  formatPanel(panel) {
    if (!panel.hasAttribute('id')) {
      panel.setAttribute('id', panel.parentNode.dataset.panelId);
    }
    panel.setAttribute('aria-labelledby', panel.parentNode.children[0].id);
    panel.classList.add('flow');
    panel.setAttribute('hidden', '');
  }
  createButton(label, panelId) {
    const button = document.createElement('button', { is: 'toggle-button' });
    button.setAttribute('aria-controls', panelId);
    button.innerHTML = "<i class='i-ri:arrow-down-s-line'></i>";
    button.prepend(label);
    return button;
  }
  generateId() {
    return Math.floor(Math.random() * Date.now()).toString(16);
  }
  isHeading(element) {
    return element.tagName.match(/^H\d$/i)
  }
  findClosestHeading(element) {
    // Check if the element is already a heading tag
    if (this.isHeading(element)) {
      return element;
    }

    // Traverse the ancestor chain and search for heading tags among their children
    let ancestor = element.parentElement;
    while (ancestor !== null) {
      const siblings = Array.from(ancestor.children);
      const headingTags = siblings.filter(sibling =>
        this.isHeading(sibling).bind(this)
      );
      if (headingTags.length > 0) {
        // Find the closest sibling heading
        const index = siblings.indexOf(element);
        if (index !== -1) {
          const closestHeading = headingTags.reduce((closest, heading) => {
            const headingIndex = siblings.indexOf(heading);
            const distance = Math.abs(headingIndex - index);
            if (closest === null || distance < closest.distance) {
              return { heading: heading, distance: distance };
            }
            return closest;
          }, null);

          if (closestHeading !== null) {
            return closestHeading.heading;
          }
        }
      }
      ancestor = ancestor.parentElement;
    }

    // No heading tag found among ancestors' children
    return null;
  }
}

customElements.define('nyc-accordion', NYCAccordion);</code></pre></div></nyc-accordion>
</div></div></main><footer class="site-footer"><div class="container"><div class="row"><div class="column"><p>Â© 2023 City of New York</p></div></div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script><script src="https://nycdigitalservice.github.io/dof-design-system/assets/main.js"></script><script>try{hljs.highlightAll();} catch(e) {}</script></body></html>